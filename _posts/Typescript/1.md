### 이펙티브 타입스크립트 정리
#### 동작 원리의 이해와 구체적인 조언 62가지

1. <span style="color:blue">타입스크립트와 자바스크립트의 관계 이해하기</span>

- 타입스크립트는 자바스크립트의 상위 집합
- 모든 자바스크립트 프로그램은 타입스크립트다.
- 타입스크립트 프로그램 = 자바스크립트 프로그램 + 타입체커를 통과한 타입스크립트 프로그램
- 타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 모델링

2. <span style="color:blue">타입스크립트 설정 이해하기</span>

- 100개 가량의 타입스크립트 설정 존재
- noImplicitAny: 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어
- strictNullChecks: null과 undifined가 모든 타입에서 허용되는지 확인
```typescript
const x: number = null; // 에러 발생
// null 형식은 number 형식에 할당할 수 없습니다.

```

3. <span style="color:blue">코드 생성과 타입이 관계없음을 이해하기</span>

- 첫번째, 최신 자바스크립트/타입스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일
- 두번째, 코드의 타입 오류 체크
- 타입 오류가 존재하더라도 컴파일 가능

4. <span style="color:blue">구조적 타이핑에 익숙해지기</span>

- 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 갖지않음
```typescript
interface Verctor2D {
    x: number;
    y: number;
}
interface NamedVector {
    name: string;
    x: number;
    y: number;
}
const v: NamedVector = { x: 3, y: 4, name: 'Zee' };
calculateLength(v);

// 구조적 타이핑 관점에서 x, y가 있어서
// NamedVector를 위한 별도의 CalculateLength를 구현할 필요가 없다.

```

5. <span style="color:blue">any 타입 지양하기</span>

- any 타입에는 타입 안전성이 없다.
- any는 함수 시그니처를 무시한다.
- any 타입에는 언어 서비스가 적용되지 않는다.
- any 타입은 코드 리펙터링 때 버그를 감춘다.
- any는 타입 설계를 감춘다.
- any는 타입시스템의 신뢰도를 떨어뜨린다.
- 자세한 내용은 4장과 5장

6. <span style="color:blue">편집기를 사용하여 타입 시스템 탐색하기 </span>

- 편집기에서 타입스크립트 언어 서비스를 적극 활용
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지 추론 가능

7. <span style="color:blue">타입이 값들의 집합이라고 생각하기</span>

- &  연사자는 두 타입의 교집합을 계산
```typescript
interface Person {
    name: string;
}
interface Lifespan {
    birth: Date;
    death?: Date;
}
type PersonSpan = Person & Liftspan;
```
- | 연산자의 keyof는 공집합
```typescript
keyof(A&B) = (keyof A) | (keyof B)
keyof(A|B) = (keyof A) & (keyof B)
```
- extends
```typescript
interface Person {
    name: string;
}
interface PersonSpan extends Person {
    birth?: Date;
    death?: Date;
}

// 서브 타입
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
```

8. <span style="color:blue">타입 공간과 값 공간의 심벌 구분하기</span>

- 타입스크립트에서 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야한다. (타입스크립트 플레이그라운드 이용)
- 모든 값은 타입을 가지지만 타입은 값을 가지지 않는다.
- 많은 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용된다.

9. <span style="color:blue">타입 단언보다는 타입 선언을 사용하기</span>

- 타입 선언
```typescript
interface Person { name: string };

const alice: Person = { name: 'Alice' };
```
- 타입 단언
```typescript
interface Person { name: string };

const bob = { name: 'Bob' } as Person;
```
- 타입 선언을 선호하는 이유
```typescript
// case 1
const alice: Person = {};
// 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.

const bob = {} as Person; // 오류 없음

// case2

const alice: Person = {
    name: 'Alice',
    occupation: 'TypeScript developer'
}
// 개체 리터럴은 알려진 속성만 지정할 수 있으며
// 'Person' 형식에 'occupation'이 없습니다.

const bob = {
    name: 'Bob',
    occupation: 'JavaScript developer'
} as Person; // 오류 없음
```
- 화살표 함수 타입 선언
```typescript
const people = ['alice', 'bob', 'jan'].map((name): Person => ({name}){
  ...
});
```

10. <span style="color:blue">객체 래퍼 타입 피하기</span>

- string 객체 래퍼
```typescript
function getStringLen(foo: String) {
    return foo.length;
}
getStringLen("hello"); // 정상
getStringLen(new String("hello")); // 정상

function inGreeting(phrase: String) {
    return ['hello', 'good day'].includes(phrase);
}
// 'String' 형식의 인수는 'string' 형식의 매개변쉥 할당할 수 없음
```